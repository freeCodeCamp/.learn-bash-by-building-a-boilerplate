"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const js_yaml_1 = require("js-yaml");
const args_1 = require("./utils/args");
const promise_1 = __importDefault(require("simple-git/promise"));
const exec_1 = require("./utils/exec");
const commits_1 = require("./utils/commits");
async function validate(args) {
    var _a, _b, _c, _d, _e, _f, _g;
    const dir = !args.length || args[0].match(/^-/) ? '.' : args[0];
    const localDir = path_1.join(process.cwd(), dir);
    const options = {
        yaml: args_1.getArg(args, { name: 'yaml', alias: 'y' }) || 'coderoad.yaml',
        clean: args_1.getArg(args, { name: 'clean', alias: 'c' }) !== 'false'
    };
    const _yaml = await fs_extra_1.readFile(path_1.join(localDir, options.yaml), 'utf8');
    let skeleton;
    try {
        skeleton = js_yaml_1.load(_yaml);
        if (!skeleton) {
            throw new Error('Invalid yaml file contents');
        }
    }
    catch (e) {
        console.error('Error parsing yaml');
        console.error(e.message);
        return;
    }
    const codeBranch = skeleton.config.repo.branch;
    const commits = await commits_1.getCommits({ localDir, codeBranch });
    const tmpDir = path_1.join(localDir, '.tmp');
    try {
        if (!(await fs_extra_1.pathExists(tmpDir))) {
            await fs_extra_1.emptyDir(tmpDir);
        }
        const tempGit = promise_1.default(tmpDir);
        await tempGit.init();
        await tempGit
            .addRemote('origin', skeleton.config.repo.uri)
            .catch(console.warn);
        await tempGit.fetch('origin', skeleton.config.repo.branch);
        const cherryPick = exec_1.createCherryPick(tmpDir);
        const runCommands = exec_1.createCommandRunner(tmpDir);
        const runTest = exec_1.createTestRunner(tmpDir, skeleton.config.testRunner);
        console.info('* Setup');
        if (commits.INIT) {
            console.info('-- Loading commits...');
            await cherryPick(commits.INIT);
            if ((_b = (_a = skeleton.config) === null || _a === void 0 ? void 0 : _a.setup) === null || _b === void 0 ? void 0 : _b.commands) {
                console.info('-- Running commands...');
                await runCommands((_d = (_c = skeleton.config) === null || _c === void 0 ? void 0 : _c.setup) === null || _d === void 0 ? void 0 : _d.commands);
            }
        }
        for (const level of skeleton.levels) {
            console.info(`* ${level.id}`);
            if (level === null || level === void 0 ? void 0 : level.setup) {
                if (commits[`${level.id}`]) {
                    console.log(`-- Loading commits...`);
                    await cherryPick(commits[level.id]);
                }
                if ((_e = level.setup) === null || _e === void 0 ? void 0 : _e.commands) {
                    console.log(`-- Running commands...`);
                    await runCommands(level.setup.commands);
                }
            }
            if (level.steps) {
                for (const step of level.steps) {
                    console.info(`** ${step.id}`);
                    const stepSetupCommits = commits[`${step.id}:T`];
                    if (stepSetupCommits) {
                        console.info(`--- Loading setup commits...`);
                        await cherryPick(stepSetupCommits);
                    }
                    if ((_f = step === null || step === void 0 ? void 0 : step.setup) === null || _f === void 0 ? void 0 : _f.commands) {
                        console.info(`--- Running setup commands...`);
                        await runCommands(step.setup.commands);
                    }
                    const stepSolutionCommits = commits[`${step.id}:S`];
                    const hasSolution = step.solution || stepSolutionCommits;
                    if (hasSolution) {
                        console.info('--- Running setup test...');
                        const { stdout, stderr } = await runTest();
                        if (stdout) {
                            console.error(`--- Expected ${step.id} setup tests to fail, but passed`);
                            console.log(stdout);
                        }
                    }
                    if (stepSolutionCommits) {
                        console.info(`--- Loading solution commits...`);
                        await cherryPick(stepSolutionCommits);
                    }
                    if ((_g = step === null || step === void 0 ? void 0 : step.solution) === null || _g === void 0 ? void 0 : _g.commands) {
                        console.info(`--- Running solution commands...`);
                        await runCommands(step.solution.commands);
                    }
                    if (hasSolution) {
                        console.info('--- Running solution test...');
                        const { stdout, stderr } = await runTest();
                        if (stderr) {
                            console.error(`--- Expected ${step.id} solution tests to pass, but failed`);
                            console.log(stderr);
                        }
                    }
                }
            }
        }
        console.info(`\n✔ Success!`);
    }
    catch (e) {
        console.error('\n✘ Fail!');
        console.error(e.message);
    }
    finally {
        if (options.clean) {
            await fs_extra_1.emptyDir(tmpDir);
        }
    }
}
exports.default = validate;
//# sourceMappingURL=validate.js.map