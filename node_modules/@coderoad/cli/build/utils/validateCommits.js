"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCommitOrder = void 0;
function validateCommitOrder(positions) {
    const errors = [];
    let previous = { level: 0, step: 0, type: '' };
    let current = { level: 0, step: 0, type: '' };
    positions.forEach((position, index) => {
        var _a, _b;
        if (position === 'INIT') {
            if (previous.level !== 0 && previous.step !== 0) {
                errors.push(index);
            }
            current = { level: 0, step: 0, type: '' };
            return;
        }
        else {
            const levelMatch = position.match(/^(?<level>[0-9]+)$/);
            const stepMatch = position.match(/^(?<level>[0-9]+)\.(?<step>[0-9]+):(?<stepType>[T|S])$/);
            if (levelMatch) {
                const levelString = (_a = levelMatch === null || levelMatch === void 0 ? void 0 : levelMatch.groups) === null || _a === void 0 ? void 0 : _a.level;
                if (!levelString) {
                    console.warn(`No commit level match for ${position}`);
                    return;
                }
                const level = Number(levelString);
                current = { level, step: 0, type: '' };
            }
            else if (stepMatch) {
                if (!((_b = stepMatch === null || stepMatch === void 0 ? void 0 : stepMatch.groups) === null || _b === void 0 ? void 0 : _b.level) || !(stepMatch === null || stepMatch === void 0 ? void 0 : stepMatch.groups.step)) {
                    console.warn(`No commit step match for ${position}`);
                    return;
                }
                const { level: levelString, step: stepString } = stepMatch.groups;
                const level = Number(levelString);
                const step = Number(stepString);
                const type = stepMatch === null || stepMatch === void 0 ? void 0 : stepMatch.groups.stepType;
                const sameStep = previous.level === level && previous.step === step;
                if ((sameStep && type === 'T' && previous.type === 'S') ||
                    (!sameStep && type === 'S')) {
                    errors.push(index);
                }
                current = { level, step, type };
            }
            else {
                console.warn(`Invalid commit position: ${position}`);
                return;
            }
            if (current.level < previous.level ||
                (current.level === previous.level && current.step < previous.step)) {
                errors.push(index);
            }
        }
        previous = current;
    });
    if (errors.length && process.env.NODE_ENV !== 'test') {
        console.warn('Found commit positions out of order');
        positions.forEach((position, index) => {
            if (errors.includes(index)) {
                console.warn(`${position} <-`);
            }
            else {
                console.log(position);
            }
        });
    }
    return !errors.length;
}
exports.validateCommitOrder = validateCommitOrder;
//# sourceMappingURL=validateCommits.js.map