"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.parseMdContent = void 0;
const lodash_1 = require("lodash");
const R = {
    summary: /^#\s(?<tutorialTitle>.*)[\n\r]+(?<tutorialDescription>[^]*)/,
    level: /^(#{2}\s(?<levelId>L?\d+\.?)\s(?<levelTitle>.*)[\n\r]*(>\s(?<levelSummary>.*))?[\n\r]+(?<levelContent>[^]*))/,
    step: /^(#{3}\s(?<stepTitle>.*)[\n\r]+(?<stepContent>[^]*))/,
    hints: /^(#{4}\sHINTS[\n\r]+([\*|\-]\s(?<hintContent>[^]*))[\n\r]+)+/,
    subtasks: /^(#{4}\sSUBTASKS[\n\r]+([\*|\-]\s(?<subtaskContent>[^]*))[\n\r]+)+/,
    listItem: /[\n\r]+[\*|\-]\s/
};
function parseMdContent(md) {
    let start = -1;
    const parts = [];
    const lines = md.split('\n');
    lines.forEach((line, index) => {
        if (line.match(/^#{1,5}\s/) || index === lines.length - 1) {
            if (start !== -1) {
                parts.push(lines.slice(start, index).join('\n'));
                start = index;
            }
            else {
                start = index;
            }
        }
    });
    const mdContent = {
        summary: {
            title: '',
            description: ''
        },
        levels: []
    };
    const summaryMatch = parts.shift().match(R.summary);
    if (summaryMatch.groups.tutorialTitle) {
        mdContent.summary.title = summaryMatch.groups.tutorialTitle.trim();
    }
    if (summaryMatch.groups.tutorialDescription) {
        mdContent.summary.description = summaryMatch.groups.tutorialDescription.trim();
    }
    let current = { levelId: '', levelIndex: -1, stepIndex: -1 };
    parts.forEach((section) => {
        const levelMatch = section.match(R.level);
        if (levelMatch && levelMatch.groups) {
            const levelId = levelMatch.groups.levelId.replace('.', '');
            current = {
                levelId: levelId,
                levelIndex: current.levelIndex + 1,
                stepIndex: -1
            };
            const { levelTitle, levelSummary, levelContent } = levelMatch.groups;
            mdContent.levels[current.levelIndex] = {
                id: levelId,
                title: levelTitle.trim(),
                summary: levelSummary && levelSummary.trim().length
                    ? levelSummary.trim()
                    : lodash_1.truncate(levelContent.split(/[\n\r]+/)[0].trim(), {
                        length: 80,
                        omission: '...'
                    }),
                content: levelContent.trim(),
                steps: []
            };
        }
        else {
            const stepMatch = section.match(R.step);
            if (stepMatch && stepMatch.groups) {
                current = {
                    levelId: current.levelId,
                    levelIndex: current.levelIndex,
                    stepIndex: current.stepIndex + 1
                };
                const { stepId, stepContent } = stepMatch.groups;
                mdContent.levels[current.levelIndex].steps[current.stepIndex] = {
                    id: `${current.levelId}.${current.stepIndex + 1}`,
                    content: stepContent.trim()
                };
            }
            else {
                const hintMatch = section.match(R.hints);
                const subtaskMatch = section.match(R.subtasks);
                switch (true) {
                    case !!hintMatch:
                        const hints = section
                            .split(R.listItem)
                            .slice(1)
                            .map(h => h.trim());
                        if (hints.length) {
                            mdContent.levels[current.levelIndex].steps[current.stepIndex].hints = hints;
                        }
                        return;
                    case !!subtaskMatch:
                        const subtasks = section
                            .split(R.listItem)
                            .slice(1)
                            .map(h => h.trim());
                        if (subtasks.length) {
                            mdContent.levels[current.levelIndex].steps[current.stepIndex].subtasks = subtasks;
                        }
                        return;
                    default:
                        console.warn(`No build parser match found for:\n${section}\n`);
                }
            }
        }
    });
    return mdContent;
}
exports.parseMdContent = parseMdContent;
function parse(params) {
    var _a;
    const mdContent = parseMdContent(params.text + '\n\n');
    const parsed = {
        id: params.skeleton.id,
        version: params.skeleton.version,
        summary: mdContent.summary,
        config: params.skeleton.config || {},
        levels: []
    };
    if (params.commits.INIT && params.commits.INIT.length) {
        parsed.config.setup = {
            ...(((_a = parsed.config) === null || _a === void 0 ? void 0 : _a.setup) || {}),
            commits: params.commits.INIT
        };
    }
    parsed.levels = mdContent.levels.map((mdLevel, mdLevelIndex) => {
        let level = { ...mdLevel };
        const configLevel = params.skeleton.levels[mdLevelIndex];
        if (configLevel) {
            const { steps, ...configLevelProps } = configLevel;
            level = { ...configLevelProps, ...level };
            if (steps) {
                steps.forEach((step, index) => {
                    try {
                        const mdStep = level.steps[index];
                        step = {
                            ...step,
                            ...mdStep
                        };
                        const stepSetupKey = `${step.id}:T`;
                        if (!(step === null || step === void 0 ? void 0 : step.setup)) {
                            step.setup = {};
                        }
                        if (!step.setup.commits) {
                            step.setup.commits = [];
                        }
                        if (params.commits[stepSetupKey]) {
                            step.setup.commits = params.commits[stepSetupKey];
                        }
                        const stepSolutionKey = `${step.id}:S`;
                        if (params.commits[stepSolutionKey]) {
                            if (!step.solution) {
                                step.solution = {
                                    commits: []
                                };
                            }
                            step.solution.commits = params.commits[stepSolutionKey];
                        }
                    }
                    catch (error) {
                        console.error('Error parsing level steps');
                        console.warn(JSON.stringify(level.steps));
                        console.error(error.message);
                    }
                    level.steps[index] = step;
                });
            }
        }
        if (params.commits[level.id]) {
            if (!level.setup) {
                level.setup = {};
            }
            level.setup.commits = params.commits[level.id];
        }
        if (params.commits[`L${level.id}`]) {
            if (!level.setup) {
                level.setup = {};
            }
            level.setup.commits = params.commits[`L${level.id}`];
        }
        return level;
    });
    return parsed;
}
exports.parse = parse;
//# sourceMappingURL=parse.js.map